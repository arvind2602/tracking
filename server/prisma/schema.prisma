generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model organiation {
  id         String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime?  @updatedAt
  showBanner Boolean    @default(false)
  logo       String?
  Site       Site[]
  employees  employee[]
  projects   projects[]
}

model employee {
  id               String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  firstName        String
  lastName         String
  email            String
  position         String
  role             role
  createdAt        DateTime       @default(now())
  updatedAt        DateTime?      @updatedAt
  is_archived      Boolean        @default(false)
  organiationId    String         @db.Uuid
  password         String
  lastDeviceId     String?
  TimeLog          TimeLog[]
  comments         comment[]
  organiation      organiation    @relation(fields: [organiationId], references: [id])
  taskAssignees    TaskAssignee[]
  skills           String[]       @default([])
  responsibilities String[]       @default([])
  dob              DateTime?
  bloodGroup       String?
  image            String?
  phoneNumber      String?
  emergencyContact String?
  address          String?
  joiningDate      DateTime?
  headedProjects   projects[]     @relation("ProjectHead")
}

model projects {
  id             String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  description    String
  startDate      DateTime
  createdAt      DateTime    @default(now())
  updatedAt      DateTime?   @updatedAt
  organiationId  String      @db.Uuid
  is_archived    Boolean     @default(false)
  endDate        DateTime?
  priority_order Int?        @default(0)
  organiation    organiation @relation(fields: [organiationId], references: [id])
  task           task[]
  headId         String?     @db.Uuid
  head           employee?   @relation("ProjectHead", fields: [headId], references: [id])
}

model task {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  description String
  status      String
  createdBy   String
  assignedTo  String?
  assigned_at DateTime?
  points      Float
  createdAt   DateTime  @default(now())
  updatedAt   DateTime? @updatedAt
  projectId   String    @db.Uuid
  dueDate     DateTime?
  order       Int       @default(0)
  priority    Priority  @default(MEDIUM)
  completedAt DateTime?
  comments    comment[]
  project     projects  @relation(fields: [projectId], references: [id])

  parent   task?   @relation("SubTasks", fields: [parentId], references: [id])
  parentId String? @db.Uuid
  subtasks task[]  @relation("SubTasks")

  type      TaskType       @default(SINGLE)
  assignees TaskAssignee[]

  @@index([projectId, status], map: "idx_task_project_status")
  @@index([assignedTo, status, updatedAt(sort: Desc)], map: "idx_task_assigned_status")
  @@index([projectId], map: "idx_task_project")
  @@index([projectId, order, createdAt(sort: Desc)], map: "idx_task_project_order")
  @@index([parentId], map: "idx_task_parent")
}

model TaskAssignee {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  taskId      String    @db.Uuid
  employeeId  String    @db.Uuid
  order       Int? // For sequential tasks
  isCompleted Boolean   @default(false)
  assignedAt  DateTime? @default(now())
  completedAt DateTime?

  task     task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  employee employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([taskId, employeeId])
  @@index([taskId])
  @@index([employeeId])
}

model comment {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  content   String
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
  taskId    String    @db.Uuid
  authorId  String    @db.Uuid
  author    employee  @relation(fields: [authorId], references: [id])
  task      task      @relation(fields: [taskId], references: [id])

  @@index([authorId], map: "idx_comment_author")
  @@index([taskId, createdAt(sort: Desc)], map: "idx_comment_task")
}

model Site {
  id             String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  description    String?
  latitude       Float
  longitude      Float
  organizationId String      @db.Uuid
  createdAt      DateTime    @default(now())
  updatedAt      DateTime?
  organiation    organiation @relation(fields: [organizationId], references: [id])
}

model TimeLog {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  employeeId String    @db.Uuid
  checkIn    DateTime  @default(now())
  checkOut   DateTime?
  type       LogType   @default(WORK)
  reason     String?
  latitude   Float?
  longitude  Float?
  deviceId   String?
  deviceType String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime?
  employee   employee  @relation(fields: [employeeId], references: [id])
}

enum Priority {
  LOW
  MEDIUM
  HIGH
}

enum role {
  ADMIN
  USER
}

enum LogType {
  WORK
  LUNCH
  BREAK
  WASHROOM
  PERSONAL_EMERGENCY
  HOME
  OTHER
}

enum TaskType {
  SINGLE
  SHARED
  SEQUENTIAL
}
